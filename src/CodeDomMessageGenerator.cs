using System;
using System.Text;
using System.Reflection;
using System.IO;
using System.CodeDom;
using System.CodeDom.Compiler;
using Microsoft.CSharp;

namespace ROS2CSMessageGenerator
{
	public class CodeDomMessageGenerator : IMessageCodeGenerator
	{
		private CodeCompileUnit TargetUnit;
		private CodeTypeDeclaration MessageStruct;
		private CodeTypeDeclaration MessageArrayStruct;
		private CodeTypeDeclaration MessageClass;
		private CodeNamespace MessageNamespace;
		private CompilerResults LastCompilationResults;
		public CodeDomMessageGenerator()
		{
		}
		/// <summary>
		/// Generates the code.
		/// </summary>
		/// <param name="description">Description.</param>
		public void GenerateCode(MessageDescription description)
		{
			//Create a compile unit
			TargetUnit = new CodeCompileUnit();

			//Create the message namespace with srv or msg.
			if (description.IsService)
				MessageNamespace = new CodeNamespace(description.Namespace + ".srv");
			else
				MessageNamespace = new CodeNamespace(description.Namespace + ".msg");
			MessageNamespace.Comments.Add(new CodeCommentStatement("Generated by the rosidl_generator_cs build: " + this.GetType().Assembly.GetName().Version.ToString()));
			MessageNamespace.Comments.Add(new CodeCommentStatement("Generation date: " + System.DateTime.Now.ToString()));
			MessageNamespace.Comments.Add(new CodeCommentStatement(description.InputFile));
			//Add using statements
			MessageNamespace.Imports.Add(new CodeNamespaceImport("System"));
			MessageNamespace.Imports.Add(new CodeNamespaceImport("rclcs"));
			MessageNamespace.Imports.Add(new CodeNamespaceImport("System.Runtime.InteropServices"));

			//Create the message struct
			MessageStruct = new CodeTypeDeclaration(description.StructName);
			MessageStruct.IsStruct = true;
			MessageStruct.BaseTypes.Add(new CodeTypeReference("IRosMessage"));
			//Add layoutkind attribute
			CodeAttributeDeclaration StructAttribute = new CodeAttributeDeclaration("StructLayout", new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(System.Runtime.InteropServices.LayoutKind)), "Sequential")));
			MessageStruct.CustomAttributes.Add(StructAttribute);
			MessageStruct.TypeAttributes = TypeAttributes.Public;
			CodeConstructor StructConstructor = AddStructConstructor(description);
			//Add struct members
			foreach (var item in description.Members)
			{
				AddStructMember(item, StructConstructor);
			}

			//Create an array wrapper for the struct
			MessageArrayStruct = new CodeTypeDeclaration(description.StructName + "_array");
			MessageArrayStruct.IsStruct = true;
			//MessageArrayStruct.BaseTypes.Add(new CodeTypeReference("IRosMessage"));

			CodeAttributeDeclaration ArrayStructAttribute = new CodeAttributeDeclaration("StructLayout", new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(System.Runtime.InteropServices.LayoutKind)), "Sequential")));
			MessageArrayStruct.CustomAttributes.Add(StructAttribute);
			MessageArrayStruct.TypeAttributes = TypeAttributes.Public;
			AddArrayStructMembers(description);

			//Add the interop method which obtains the typesupport
			AddTypeIntrospectionMethod(description);
			//Add the free method needed for memory handling
			AddFreeMethod();
			//Add the struct to the namespace
			MessageNamespace.Types.Add(MessageStruct);
			MessageNamespace.Types.Add(MessageArrayStruct);
			//Add to namespace
			TargetUnit.Namespaces.Add(MessageNamespace);

			//Create the wrapper class
			MessageClass = new CodeTypeDeclaration(description.Name);
			MessageClass.IsClass = true;
			MessageClass.BaseTypes.Add("MessageWrapper");

			//Add fields to the message wrapper class
			AddMessageFields(description);
			//Add the constructor
			AddMessageConstructor(description);
			//Adds all the rest of the non dynamic generated methods of the wrapper class
			AddInheritedMethods(description);
			//Add methods (Properties to be exact) for accessing the variables in the structs
			AddSimpleAccessMethods(description);
			AddArrayAccessMethods(description);
			AddNestedAccessMethods(description);
			//Add the wrapper class to the namespace
			MessageNamespace.Types.Add(MessageClass);
		}
		/// <summary>
		/// Gets the generated code.
		/// </summary>
		/// <returns>The generated code as a string.</returns>
		public string GetGeneratedCode()
		{
			CSharpCodeProvider provider = new CSharpCodeProvider();
			StringBuilder codeString = new StringBuilder();
			StringWriter writer = new StringWriter(codeString);
			CodeGeneratorOptions generatorOptions = new CodeGeneratorOptions();
			provider.GenerateCodeFromCompileUnit(TargetUnit, writer, generatorOptions);
			//This adds the unsafe statement which is not supported by codedom ->roselyn supports it
			//We need the unsafe statement for fixed size arrays
			string returnCode = AddUnsafeStatementToStruct(codeString.ToString());
			return returnCode;
		}
		/// <summary>
		/// Adds the unsafe statement to struct code.
		/// </summary>
		/// <returns>The generated code with the unsafe statement.</returns>
		/// <param name="code">Code.</param>
		private string AddUnsafeStatementToStruct(string code)
		{
			int struct_pos = code.IndexOf("struct");
			code = code.Insert(struct_pos, "unsafe ");
			return code;
		}
		/// <summary>
		/// Tests if the generated code compiles.
		/// </summary>
		/// <returns><c>true</c>, if the generated code compiles, <c>false</c> otherwise.</returns>
		/// <param name="rclcsPath">Rclcs path.</param>
		/// <param name="referencesPaths">References paths.</param>
		public bool TestCompileGeneratedCode(string rclcsPath, string[] referencesPaths)
		{
			CSharpCodeProvider provider = new CSharpCodeProvider();
			CompilerParameters compilerOptions = new CompilerParameters();
			compilerOptions.CompilerOptions += " /unsafe";
			//Add the needed references to the compiler parameters
			compilerOptions.ReferencedAssemblies.Add("System");
			compilerOptions.ReferencedAssemblies.Add(rclcsPath);
			compilerOptions.ReferencedAssemblies.AddRange(referencesPaths);
			//And compile it
			LastCompilationResults = provider.CompileAssemblyFromSource(compilerOptions, new string[] { GetGeneratedCode() });
			return false;
		}
		/// <summary>
		/// Gets the last compilation results.
		/// </summary>
		/// <returns>The last compilation results.</returns>
		public CompilerResults GetLastCompilationResults()
		{
			if (LastCompilationResults == null)
				throw new NullReferenceException("You need to start a compilation before");
			return LastCompilationResults;
		}
		/// <summary>
		/// Adds the struct constructor.
		/// </summary>
		/// <returns>The struct constructor.</returns>
		/// <param name="description">Description.</param>
		private CodeConstructor AddStructConstructor(MessageDescription description)
		{
			//Create constructor
			CodeConstructor structConstructor = new CodeConstructor();
			structConstructor.Attributes = MemberAttributes.Public;

			MessageStruct.Members.Add(structConstructor);
			return structConstructor;
		}
		/// <summary>
		/// Adds the array struct members.
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddArrayStructMembers(MessageDescription description)
		{
			//Create new field
			CodeMemberField memberField = new CodeMemberField();

			//Set it to public
			memberField.Attributes = MemberAttributes.Public;
			//Set the member name
			memberField.Name = "array_ptr";
			//Set the member type 
			memberField.Type = new CodeTypeReference(typeof(IntPtr));
			//Add the field to the struct
			MessageArrayStruct.Members.Add(memberField);

			memberField = new CodeMemberField();

			//Set it to public
			memberField.Attributes = MemberAttributes.Public;
			//Set the member name
			memberField.Name = "size";
			//Set the member type 
			memberField.Type = new CodeTypeReference(typeof(int));
			//Add the field to the struct
			MessageArrayStruct.Members.Add(memberField);

			memberField = new CodeMemberField();

			//Set it to public
			memberField.Attributes = MemberAttributes.Public;
			//Set the member name
			memberField.Name = "capacity";
			//Set the member type 
			memberField.Type = new CodeTypeReference(typeof(int));
			//Add the field to the struct
			MessageArrayStruct.Members.Add(memberField);
		}
		/// <summary>
		/// Adds the given struct member to the struct.
		/// </summary>
		/// <param name="member">Member.</param>
		private void AddStructMember(MessageMemberDescription member, CodeConstructor constructor)
		{
			if (member.IsNested)
			{
				Console.WriteLine("Nested member: " + member.MemberType + " " + member.Name);
				if (member.IsBoundedArray)
					Console.WriteLine("Is bounded array");
				if (member.IsArray)
					Console.WriteLine("Is array");
				//Create new field
				CodeMemberField memberField = new CodeMemberField();
				memberField.Comments.Add(new CodeCommentStatement("Nested member: " + member.RosType));
				//Set it to public
				memberField.Attributes = MemberAttributes.Public;
				//Set the member name
				memberField.Name = member.Name;
				//Set the member type 
				if (member.IsArray)
					memberField.Type = new CodeTypeReference(member.MemberType + "_array");
				else
					memberField.Type = new CodeTypeReference(member.MemberType);
				//Add the field to the struct
				MessageStruct.Members.Add(memberField);
			}
			else if (member.IsFixedSizeArray)
			{
				//For a fixed size array we need a customMeber
				CodeSnippetTypeMember customMember = new CodeSnippetTypeMember();
				customMember.Comments.Add(new CodeCommentStatement("Fixed size array member: " + member.RosType));
				//With some custom code
				customMember.Text = "        public fixed " + member.MemberType + " " + member.Name + "[" + member.FixedArraySize.ToString() + "];\n";
				//Add this code to the struct
				MessageStruct.Members.Add(customMember);
			}
			else
			{
				//Create new field
				CodeMemberField memberField = new CodeMemberField();
				memberField.Comments.Add(new CodeCommentStatement("Standard member: " + member.RosType));
				//Set it to public
				memberField.Attributes = MemberAttributes.Public;
				//Set the member name
				memberField.Name = member.Name;
				//Set the member type 
				memberField.Type = new CodeTypeReference(member.MemberType);
				//Add the field to the struct
				MessageStruct.Members.Add(memberField);
				//Handling for DefaultValue
				if (member.DefaultInitialisation != "")
				{
					//Parse for ints //TODO parse other types
					int val;
					bool success = int.TryParse(member.DefaultInitialisation, out val);
					if (success)
					{
						CodeAssignStatement assignDefaultVal = new CodeAssignStatement(new CodeVariableReferenceExpression(member.Name), new CodePrimitiveExpression(val));
						constructor.Statements.Add(assignDefaultVal);
					}

				}
			}


		}
		/// <summary>
		/// Adds the type introspection method.
		/// </summary>
		/// <param name="description">Message description.</param>
		private void AddTypeIntrospectionMethod(MessageDescription description)
		{
			CodeSnippetTypeMember introspectionMethod = new CodeSnippetTypeMember();
			string introspectionMethodName = "";
			if (description.IsService)
			{
				string tempName = description.Name.Replace("_", "");
				tempName = tempName.Replace("Request", "");
				tempName = tempName.Replace("Response", "");
				introspectionMethodName = "rosidl_typesupport_introspection_c_get_message__" + description.Namespace + "__srv__" + tempName;
			}
			else
			{
				introspectionMethodName = "rosidl_typesupport_introspection_c_get_message__" + description.Namespace + "__msg__" + description.Name;
			}
			introspectionMethod.Text = "        [DllImport (\"lib" + description.Namespace + "__rosidl_typesupport_introspection_c.so\")]\n" +
				"        public static extern IntPtr " + introspectionMethodName + "();";
			MessageStruct.Members.Add(introspectionMethod);
		}
		/// <summary>
		/// Adds the free method for memory handling.
		/// </summary>
		private void AddFreeMethod()
		{
			CodeMemberMethod freeMethod = new CodeMemberMethod();
			freeMethod.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			freeMethod.Name = "Free";
			freeMethod.ReturnType = new CodeTypeReference(typeof(void));

			freeMethod.Comments.Add(new CodeCommentStatement("This method calls free on every sub element if the subelement implements the IRosTransportItem interface"));
			CodeSnippetStatement freeIteration = new CodeSnippetStatement();
			freeIteration.Value =
				"           foreach (var item in this.GetType().GetFields()) " +
				"{\n            " +
					"  if (typeof(IRosTransportItem).IsAssignableFrom (item.FieldType))" +
					"{\n               " +
						"    IRosTransportItem ros_transport_item = (IRosTransportItem)item.GetValue(this);" +
					"\n                   ros_transport_item.Free();" +
				"\n              }" +
				"\n           }";
			freeMethod.Statements.Add(freeIteration);
			MessageStruct.Members.Add(freeMethod);
		}
		/// <summary>
		/// Adds all fields to the message wrapper class. This contains fields needed for the IDisposable Pattern and fields needed for caching nested types
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddMessageFields(MessageDescription description)
		{
			//Boolean field for disposable pattern
			CodeMemberField disposeField = new CodeMemberField();
			disposeField.Attributes = MemberAttributes.Private;
			disposeField.Name = "disposed";
			disposeField.Type = new CodeTypeReference(typeof(bool));


			MessageClass.Members.Add(disposeField);

			//This field contains the data struct
			CodeMemberField dataField = new CodeMemberField();
			dataField.Attributes = MemberAttributes.Private;
			dataField.Name = "__data";
			dataField.Type = new CodeTypeReference(description.StructName);

			MessageClass.Members.Add(dataField);

			//Here we add all needed fields that cache access to the nested types
			foreach (var item in description.Members)
			{
				if (item.IsNested)
				{
					CodeMemberField nestedField = new CodeMemberField();
					nestedField.Attributes = MemberAttributes.Private;
					nestedField.Name = "__" + item.Name;
					//We need to remove the _t because we want the class type and not the struct type
					//TODO Find a nicer solution?
					nestedField.Type = new CodeTypeReference(item.MemberType.Remove(item.MemberType.Length - 2, 2));
					MessageClass.Members.Add(nestedField);
				}
			}



		}
		/// <summary>
		/// Adds the constructors to the message class.
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddMessageConstructor(MessageDescription description)
		{

			CodeConstructor constructor = new CodeConstructor();
			constructor.Name = description.Name;
			constructor.Attributes = MemberAttributes.Public;
			CodeParameterDeclarationExpression constructorParameter = new CodeParameterDeclarationExpression();
			constructorParameter.Name = "_data";
			constructorParameter.Type = new CodeTypeReference(description.StructName);
			constructorParameter.Direction = FieldDirection.Ref;
			constructor.Parameters.Add(constructorParameter);

			CodeAssignStatement constructorStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__data"), new CodeVariableReferenceExpression("_data"));
			constructor.Statements.Add(constructorStatement);
			MessageClass.Members.Add(constructor);

			CodeConstructor emptyConstructor = new CodeConstructor();
			emptyConstructor.Name = description.Name;
			emptyConstructor.Attributes = MemberAttributes.Public;
			foreach (var item in description.Members)
			{
				if (item.IsNested)
				{
					CodeAssignStatement nestedCreateStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__" + item.Name), new CodeVariableReferenceExpression("new " + item.MemberType.Remove(item.MemberType.Length - 2, 2) + "()"));
					emptyConstructor.Statements.Add(nestedCreateStatement);
				}
			}
			MessageClass.Members.Add(emptyConstructor);

		}
		/// <summary>
		/// Adds and implements the inherited (or generally expected methods) from MessageWrapper.
		/// This includes <T> Data, static Type GetMessageType, GetData(out ValueType _data), SetData(ref ValueType _data);
		/// </summary>
		private void AddInheritedMethods(MessageDescription description)
		{
			//This property returns the data struct (To be exact: A copy of it)
			CodeMemberProperty dataProperty = new CodeMemberProperty();
			dataProperty.Name = "Data";
			dataProperty.Type = new CodeTypeReference(description.StructName);
			dataProperty.Attributes = MemberAttributes.Public;
			dataProperty.Comments.Add(new CodeCommentStatement("Returns the underlying struct which is wrapped by this class. This struct will be sent in the end"));

			CodeMethodReturnStatement dataPropertyReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__data"));
			dataProperty.GetStatements.Add(dataPropertyReturnStatement);

			MessageClass.Members.Add(dataProperty);

			//THis method returns the type of the stored message struct
			CodeMemberMethod messageTypeMethod = new CodeMemberMethod();
			messageTypeMethod.Attributes = MemberAttributes.Public | MemberAttributes.Static;
			messageTypeMethod.Name = "GetMessageType";
			messageTypeMethod.ReturnType = new CodeTypeReference(typeof(Type));
			CodeSnippetStatement messageTypeMethodReturnStatement = new CodeSnippetStatement("            return typeof(" + description.StructName + ");"); //Insert spaces for nice formatting -.-
			messageTypeMethod.Statements.Add(messageTypeMethodReturnStatement);

			MessageClass.Members.Add(messageTypeMethod);

			//This method returns the data struct (I think a reference to it)
			CodeMemberMethod getDataMethod = new CodeMemberMethod();
			getDataMethod.Attributes = MemberAttributes.Public | MemberAttributes.Override;
			getDataMethod.Name = "GetData";
			CodeParameterDeclarationExpression getDataMethodParameter = new CodeParameterDeclarationExpression();
			getDataMethodParameter.Name = "_data";
			getDataMethodParameter.Direction = FieldDirection.Out;
			getDataMethodParameter.Type = new CodeTypeReference(typeof(ValueType));

			getDataMethod.Parameters.Add(getDataMethodParameter);

			getDataMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("_data"), new CodeVariableReferenceExpression("__data")));

			MessageClass.Members.Add(getDataMethod);


			//And the set method
			CodeMemberMethod setDataMethod = new CodeMemberMethod();
			setDataMethod.Attributes = MemberAttributes.Public | MemberAttributes.Override;
			setDataMethod.Name = "SetData";
			CodeParameterDeclarationExpression setDataMethodParameter = new CodeParameterDeclarationExpression();
			setDataMethodParameter.Name = "_data";
			setDataMethodParameter.Direction = FieldDirection.Ref;
			setDataMethodParameter.Type = new CodeTypeReference(typeof(ValueType));

			setDataMethod.Parameters.Add(setDataMethodParameter);

			setDataMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("__data"), new CodeVariableReferenceExpression("(" + description.StructName + ")_data")));

			MessageClass.Members.Add(setDataMethod);

			//And the dispose method
			CodeMemberMethod disposeMethod = new CodeMemberMethod();
			disposeMethod.Name = "Dispose";
			disposeMethod.Attributes = MemberAttributes.Override | MemberAttributes.Family;

			CodeParameterDeclarationExpression disposeMethodParameter = new CodeParameterDeclarationExpression();
			disposeMethodParameter.Name = "disposing";
			disposeMethodParameter.Type = new CodeTypeReference(typeof(bool));
			disposeMethod.Parameters.Add(disposeMethodParameter);


			CodeConditionStatement disposedCheckStatement = new CodeConditionStatement();
			disposedCheckStatement.Condition = new CodeVariableReferenceExpression("disposed");

			disposedCheckStatement.TrueStatements.Add(new CodeMethodReturnStatement());
			CodeMethodInvokeExpression invokeDisposeStatement = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__data"), "Free", new CodeTypeReference[] { }));
			disposedCheckStatement.FalseStatements.Add(invokeDisposeStatement);
			disposeMethod.Statements.Add(disposedCheckStatement);
			disposeMethod.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("disposed"), new CodePrimitiveExpression(true)));
			MessageClass.Members.Add(disposeMethod);

			//And the SyncDataOut method
			CodeMemberMethod syncDataOutMethod = new CodeMemberMethod();
			syncDataOutMethod.Name = "SyncDataOut";
			syncDataOutMethod.Attributes = MemberAttributes.Public | MemberAttributes.Override;
			syncDataOutMethod.Comments.Add(new CodeCommentStatement("Needed to copy data from the struct in the class instance of the nested member the the real struct"));

			foreach (var item in description.Members)
			{
				if (item.IsNested && !item.IsArray)
				{
					CodeAssignStatement assignDataOutStatement = new CodeAssignStatement();
					assignDataOutStatement.Left = new CodeVariableReferenceExpression("__data." + item.Name);
					assignDataOutStatement.Right = new CodeVariableReferenceExpression("__" + item.Name + ".Data");

					syncDataOutMethod.Statements.Add(assignDataOutStatement);

					CodeMethodInvokeExpression invokeNestedOutSync = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__" + item.Name), "SyncDataOut", new CodeTypeReference[] { }));
					syncDataOutMethod.Statements.Add(invokeNestedOutSync);
				}
			}
			MessageClass.Members.Add(syncDataOutMethod);

			//SyncDataIn method
			CodeMemberMethod syncDataInMethod = new CodeMemberMethod();
			syncDataInMethod.Name = "SyncDataIn";
			syncDataInMethod.Attributes = MemberAttributes.Public | MemberAttributes.Override;
			syncDataInMethod.Comments.Add(new CodeCommentStatement("Needed to copy data from the real struct (that one that is stored in __data) to the struct in the class member of the nested type"));

			foreach (var item in description.Members)
			{
				if (item.IsNested && !item.IsArray)
				{
					CodeAssignStatement assignDataInStatement = new CodeAssignStatement();
					assignDataInStatement.Left = new CodeVariableReferenceExpression("__" + item.Name);
					//TODO use invoke expression
					assignDataInStatement.Right = new CodeVariableReferenceExpression("new " + item.MemberType.Remove(item.MemberType.Length - 2, 2) + "(ref __data." + item.Name + ")");

					syncDataInMethod.Statements.Add(assignDataInStatement);

					CodeMethodInvokeExpression invokeNestedInSync = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__" + item.Name), "SyncDataIn", new CodeTypeReference[] { }));
					syncDataInMethod.Statements.Add(invokeNestedInSync);
				}
			}
			MessageClass.Members.Add(syncDataInMethod);

		}
		/// <summary>
		/// Adds methods to the wrapper class for accessing simple fields like integers
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddSimpleAccessMethods(MessageDescription description)
		{
			foreach (var item in description.Members)
			{
				//Check for a simple type
				if (!item.IsArray && !item.IsNested && !item.IsFixedSizeArray)
				{
					CodeMemberProperty simpleAccessProperty = new CodeMemberProperty();
					simpleAccessProperty.Name = item.Name;
					simpleAccessProperty.Attributes = MemberAttributes.Public;
					simpleAccessProperty.Type = new CodeTypeReference(item.MemberType);
					//Some extra treatment for strings, they need to be handled like arrays but are still simple types
					//TODO Let strings behave like an array ?
					if (item.MemberType.Contains("String"))
					{
						simpleAccessProperty.Type = new CodeTypeReference(typeof(string));
						CodeMethodReturnStatement simpleAccessPropertyReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__data." + item.Name + ".ToString()"));
						simpleAccessProperty.GetStatements.Add(simpleAccessPropertyReturnStatement);


						CodeMethodInvokeExpression freeOldDataStatement = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__data." + item.Name), "Free", new CodeTypeReference[] { }));
						simpleAccessProperty.SetStatements.Add(freeOldDataStatement);

						CodeAssignStatement createNewDataStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__data." + item.Name), new CodeVariableReferenceExpression("new " + item.MemberType + "(value)"));
						simpleAccessProperty.SetStatements.Add(createNewDataStatement);

					}
					else
					{
						CodeMethodReturnStatement simpleAccessPropertyReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__data." + item.Name));
						simpleAccessProperty.GetStatements.Add(simpleAccessPropertyReturnStatement);

						CodeAssignStatement simpleAccessPropertySetStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__data." + item.Name), new CodeVariableReferenceExpression("value"));
						simpleAccessProperty.SetStatements.Add(simpleAccessPropertySetStatement);
					}
					MessageClass.Members.Add(simpleAccessProperty);
				}
			}
		}
		/// <summary>
		/// Adds methods for accessing arrays
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddArrayAccessMethods(MessageDescription description)
		{
			foreach (var item in description.Members)
			{
				if (item.IsArray && !item.IsFixedSizeArray && !item.IsNested)
				{
					CodeMemberProperty arrayAccessProperty = new CodeMemberProperty();
					arrayAccessProperty.Name = item.Name;
					arrayAccessProperty.Attributes = MemberAttributes.Public;
					//Some extra stuff for string arrays
					string dataAccessMethodName = "Array";
					if (item.MemberType.ToLower().Contains("string"))
					{

						arrayAccessProperty.Type = new CodeTypeReference(typeof(string[]));
					}
					else if (item.MemberType.ToLower().Contains("bool"))
					{
						//Extra handling for bool
						arrayAccessProperty.Type = new CodeTypeReference(typeof(bool[]));
					}
					else
					{

						arrayAccessProperty.Type = new CodeTypeReference(item.ArrayReturnType + "[]");
					}
					CodeMethodReturnStatement arrayAccessPropertyReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__data." + item.Name + "." + dataAccessMethodName));
					arrayAccessProperty.GetStatements.Add(arrayAccessPropertyReturnStatement);

					CodeMethodInvokeExpression freeOldDataStatement = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression("__data." + item.Name), "Free", new CodeTypeReference[] { }));
					arrayAccessProperty.SetStatements.Add(freeOldDataStatement);

					CodeAssignStatement createNewDataStatement = new CodeAssignStatement(new CodeVariableReferenceExpression("__data." + item.Name), new CodeVariableReferenceExpression("new " + item.MemberType + "(value)"));
					arrayAccessProperty.SetStatements.Add(createNewDataStatement);
					MessageClass.Members.Add(arrayAccessProperty);
				}
				else if (item.IsFixedSizeArray && !item.IsNested)
				{
					CodeMemberProperty fixedArrayAccessProperty = new CodeMemberProperty();
					fixedArrayAccessProperty.Name = item.Name;
					fixedArrayAccessProperty.Attributes = MemberAttributes.Public;

					//TODO Probably some stuff for strings is needed here
					string fixedArrayType = item.MemberType + "[]";
					fixedArrayAccessProperty.Type = new CodeTypeReference(fixedArrayType);

					CodeSnippetStatement fixedArrayGetMethod = new CodeSnippetStatement();
					fixedArrayGetMethod.Value =
											"                unsafe{\n" +
											"                    " + fixedArrayType + " temp = new " + item.MemberType + "[" + item.FixedArraySize + "];\n" +
											"                    fixed(" + item.MemberType + "* buffer = __data." + item.Name + "){\n" +
											"                        for(int i = 0; i < " + item.FixedArraySize + "; i++){\n" +
											"                            temp[i] = buffer[i];\n" +
											"                        }\n" +
											"                    }\n" +
											"                    return temp;\n" +
											"                }";

					fixedArrayAccessProperty.GetStatements.Add(fixedArrayGetMethod);

					CodeSnippetStatement fixedArraySetMethod = new CodeSnippetStatement();
					fixedArraySetMethod.Value =
											"                unsafe{\n" +
											"                    " + fixedArrayType + "temp = value;\n" +
											"                    fixed(" + item.MemberType + "* buffer = __data." + item.Name + "){\n" +
											"                        for(int i = 0; i < temp.Length; i++){\n" +
											"                            buffer[i] = temp[i];\n" +
											"                        }\n" +
											"                    }\n" +
											"                }";

					fixedArrayAccessProperty.SetStatements.Add(fixedArraySetMethod);
					MessageClass.Members.Add(fixedArrayAccessProperty);


				}
				else if (item.IsNested && item.IsArray)
				{
					CodeMemberProperty arrayAccessProperty = new CodeMemberProperty();
					arrayAccessProperty.Name = item.Name;
					arrayAccessProperty.Attributes = MemberAttributes.Public;
				}
			}

		}
		/// <summary>
		/// Adds methods for accessing nested types
		/// </summary>
		/// <param name="description">Description.</param>
		private void AddNestedAccessMethods(MessageDescription description)
		{
			foreach (var item in description.Members)
			{
				if (item.IsNested)
				{
					CodeMemberProperty nestedTypeAccessProperty = new CodeMemberProperty();
					nestedTypeAccessProperty.Name = item.Name;
					nestedTypeAccessProperty.Attributes = MemberAttributes.Public;
					nestedTypeAccessProperty.Type = new CodeTypeReference(item.MemberType.Remove(item.MemberType.Length - 2, 2));

					CodeMethodReturnStatement nestedTypeReturnStatement = new CodeMethodReturnStatement(new CodeVariableReferenceExpression("__" + item.Name));
					nestedTypeAccessProperty.GetStatements.Add(nestedTypeReturnStatement);

					MessageClass.Members.Add(nestedTypeAccessProperty);

				}
			}
		}
	}
}

